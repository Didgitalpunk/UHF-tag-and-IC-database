import sys
import json
import re
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, QTextEdit
from PyQt5.QtCore import Qt, QRegularExpression
from PyQt5.QtGui import QRegularExpressionValidator, QFontMetrics

# Remove non-printable characters except spaces, newlines, and tabs
def clean_json_data(raw_data):
    return re.sub(r'[\x00-\x1F\x7F-\x9F]', '', raw_data)

# Load JSON data
def load_json_data():
    try:
        with open("Digits'_mdid_list.json", "r", encoding="utf-8") as file:
            raw_data = file.read()
            cleaned_data = clean_json_data(raw_data)  # Clean non-printable characters
            data = json.loads(cleaned_data)  # Parse the cleaned JSON data
            print("Data loaded successfully")
            return data
    except Exception as e:
        print(f"ERROR decoding the JSON data: {e}")
        return None

# Decode the TID
def extract_values(tid):
    bin_tid = bin(int(tid, 16))[2:].zfill(32)  # Ensure we have a 32-bit binary string
    
    # Extract X, S, F values (next 3 bits)
    X = bin_tid[8]
    S = bin_tid[9]
    F = bin_tid[10]
    
    # Extract MDID (next 9 bits)
    MDID_binary = bin_tid[11:20]
    
    # Convert MDID to hex
    MDID_hex = hex(int(MDID_binary, 2))[2:].zfill(3)
    
    # Extract TMN (last 12 bits)
    TMN_binary = bin_tid[20:32]
    
    # Convert TMN to hex
    TMN_hex = hex(int(TMN_binary, 2))[2:].zfill(3)
    
    return X, S, F, MDID_binary, MDID_hex, TMN_binary, TMN_hex

def decode_xtid(xtid_parts):
    # Convert each XTID part to binary individually, ensuring each is 16 bits long
    xtid_bin_parts = [bin(int(part, 16))[2:].zfill(16) for part in xtid_parts]

    # Now concatenate all the properly padded binary parts
    xtid_bin = ''.join(xtid_bin_parts)

    # Extract individual bits based on their meaning
    extended_header_present = xtid_bin[16] == '1'
    rfu = xtid_bin[6:16]  # Bits 1-9 (keeps leading zeros)
    user_memory_present = xtid_bin[5] == '1'
    block_write_present = xtid_bin[4] == '1'
    optional_command_present = xtid_bin[3] == '1'
    serialization_bits = xtid_bin[0:3]  # Bits 13-15

    # Calculate serialization info (using the formula)
    if serialization_bits != '000':
        N = int(serialization_bits, 2)  # Convert the 3 bits to decimal
        serial_number_length = 48 + 16 * (N - 1)  # 48 + 16 * (N - 1)
        serial_number_info = f"Serialization length: {serial_number_length} bits"

        # The serial number starts from bit 16 and has the length calculated above
        serial_number_end = 16 + serial_number_length

        # Extract the serial number binary string (starting from bit 16)
        serial_number_bin = xtid_bin[16:serial_number_end].zfill(serial_number_length)

        # Convert the serial number binary string to hex
        serial_number_hex = hex(int(serial_number_bin, 2))[2:].zfill(serial_number_length // 4)

        # Prepare the output for the serial number
        serial_number_output = f"Serial Number: {serial_number_hex.upper()}"
    else:
        serial_number_info = "XTID does not include a unique serial number."
        serial_number_output = ""

    return (extended_header_present, rfu, user_memory_present, block_write_present,
            optional_command_present, serialization_bits, serial_number_info, serial_number_output)


# Main window
class SearchWindow(QWidget):
    def __init__(self, data):
        super().__init__()

        self.setWindowTitle("TID Search Engine")
        self.setGeometry(100, 100, 600, 500)
        
        self.data = data
        self.init_ui()

    def init_ui(self):
        # Layout
        main_layout = QVBoxLayout()

        # Instruction label
        instruction_label = QLabel("Enter the first 8 characters of the TID (ex: E2xx xxxx):")
        main_layout.addWidget(instruction_label)

        # Input fields (split into two 4-character boxes)
        input_layout = QHBoxLayout()
        self.tid_part1 = QLineEdit(self)
        self.tid_part2 = QLineEdit(self)

        # Set max length for each part to 4 characters
        self.tid_part1.setMaxLength(4)
        self.tid_part2.setMaxLength(4)

        # Set input fields to uppercase automatically
        self.tid_part1.textChanged.connect(self.to_uppercase)
        self.tid_part2.textChanged.connect(self.to_uppercase)

        # Automatically move focus from part1 to part2 when part1 is full
        self.tid_part1.textChanged.connect(self.auto_focus_part2)

        # Add hex validator to the input fields
        hex_validator = QRegularExpressionValidator(QRegularExpression("[0-9A-Fa-f]{0,4}"), self)
        self.tid_part1.setValidator(hex_validator)
        self.tid_part2.setValidator(hex_validator)

        # Set the width for the input fields to match 8 characters
        font = self.tid_part1.font()  # Get the current font
        metrics = QFontMetrics(font)  # Get the font metrics
        char_width = metrics.averageCharWidth()  # Calculate the average width of a character
        input_field_width = char_width * 6  # Set width to 8 characters

        # Apply the fixed width to the input fields
        self.tid_part1.setFixedWidth(input_field_width)
        self.tid_part2.setFixedWidth(input_field_width)

        # Set the alignment of the text inside the input fields to left
        self.tid_part1.setAlignment(Qt.AlignLeft)
        self.tid_part2.setAlignment(Qt.AlignLeft)

        # Add to the input layout
        input_layout.addWidget(self.tid_part1)
        input_layout.addWidget(self.tid_part2)

        # Make the input layout left justified in the main window
        input_layout.setAlignment(Qt.AlignLeft)

        main_layout.addLayout(input_layout)
        
        #########################################################################################################
        #
        #
        # Xtended TID section
        xtid_label = QLabel("Xtended TID (XTID):")
        main_layout.addWidget(xtid_label)

        # Create a horizontal layout for XTID fields
        xtid_layout = QHBoxLayout()

        # Manually creating XTID fields
        self.xtid_fields = []
        for _ in range(11):
            xtid_field = QLineEdit(self)
            xtid_field.setMaxLength(4)
            xtid_field.setValidator(QRegularExpressionValidator(QRegularExpression("[0-9A-Fa-f]{0,4}"), self))
            xtid_field.setAlignment(Qt.AlignLeft)
            xtid_field.setFixedWidth(input_field_width)  # Set the width of each field
            xtid_field.textChanged.connect(self.to_uppercase)  # Automatic capitalization
            self.xtid_fields.append(xtid_field)
            xtid_layout.addWidget(xtid_field)

        # Automatically change focus from one field to the next when a field is filled
        for i in range(len(self.xtid_fields) - 1):
            self.xtid_fields[i].textChanged.connect(lambda _, i=i: self.auto_focus_xtid(i))

        # Set the alignment of the XTID fields to the left
        xtid_layout.setAlignment(Qt.AlignLeft)

        # Add XTID layout to main layout
        main_layout.addLayout(xtid_layout)

        # Search button
        self.search_button = QPushButton("Search", self)
        self.search_button.clicked.connect(self.on_search)
        main_layout.addWidget(self.search_button)

        # Add "Chip Information" label above the results display
        chip_info_label = QLabel("Chip Information:")
        main_layout.addWidget(chip_info_label)

        # Create a horizontal layout for the output displays
        output_layout = QHBoxLayout()

        # Create two output displays (QTextEdit)
        self.result_display_left = QTextEdit(self)
        self.result_display_left.setReadOnly(True)

        self.result_display_right = QTextEdit(self)
        self.result_display_right.setReadOnly(True)

        # Add the two output displays to the layout
        output_layout.addWidget(self.result_display_left)
        output_layout.addWidget(self.result_display_right)

        # Add the output layout to the main layout
        main_layout.addLayout(output_layout)

        self.setLayout(main_layout)

        # Connect the Enter key event to the input fields
        self.tid_part1.returnPressed.connect(self.trigger_search)
        self.tid_part2.returnPressed.connect(self.trigger_search)

    def to_uppercase(self):
        sender = self.sender()
        sender.setText(sender.text().upper())  # Convert the text to uppercase

    def auto_focus_part2(self):
        if len(self.tid_part1.text()) == 4:
            self.tid_part2.setFocus()

    def auto_focus_xtid(self, current_index):
        if len(self.xtid_fields[current_index].text()) == 4 and current_index < len(self.xtid_fields) - 1:
            self.xtid_fields[current_index + 1].setFocus()

    def trigger_search(self):
        """Trigger search when Enter is pressed in any input field."""
        self.on_search()

    def on_search(self):
        part1 = self.tid_part1.text().strip()
        part2 = self.tid_part2.text().strip()

        if len(part1) == 4 and len(part2) == 4:
            full_tid = part1 + part2
            result, resultXTID = self.search_tid(full_tid)

            # Handle XTID fields
            xtid_parts = [field.text().strip() for field in self.xtid_fields]
            
            # Check for empty XTID fields and append zeros if necessary
            for i in range(len(xtid_parts)):
                if not xtid_parts[i]:
                    xtid_parts[i] = "0000"  # Fill with zeros if the field is empty

            if all(xtid_parts):
                xtid_decoded = decode_xtid(xtid_parts)
                xtid_info = (f"Extended Header Present: {xtid_decoded[0]}\n"
                             f"RFU: {xtid_decoded[1]}\n"
                             f"User Memory Present: {xtid_decoded[2]}\n"
                             f"Block Write Present: {xtid_decoded[3]}\n"
                             f"Optional Command Present: {xtid_decoded[4]}\n"
                             f"Serialization: {xtid_decoded[5]}\n"
                             f"{xtid_decoded[6]}\n"  # Serialization line
                             f"{xtid_decoded[7]}")  # Serial Number line
                resultXTID += "\n" + xtid_info
            else:
                resultXTID += "\nNo XTID input provided."

            self.result_display_left.setText(result)  # Display in the left QTextEdit
            self.result_display_right.setText(resultXTID)  # Display XTID info in the right QTextEdit
        else:
            self.result_display_left.setText("Please enter 8 characters, split into two 4-character parts.")
            self.result_display_right.setText("")


    def search_tid(self, tid):
        if self.data is None:
            return "Error: No data available to search.", ""

        X, S, F, MDID_binary, MDID_hex, TMN_binary, TMN_hex = extract_values(tid)

        decoded_info = (f"Xtid bit: {X}, Security bit: {S}, File bit: {F}\n"
                        f"MDID: {MDID_binary} (binary), {MDID_hex} (hex)\n"
                        f"TMN: {TMN_binary} (binary), {TMN_hex} (hex)")

        result = decoded_info + "\n\n"
        resultXTID = "XTID information: \n"

        try:
            for designer in self.data.get('registeredMaskDesigners', []):
                if designer['mdid'] == MDID_binary:
                    result += (f"Manufacturer: {designer['manufacturer']}\n"
                               f"Manufacturer URL: {designer['manufacturerUrl']}\n\n")
                    
                    for chip in designer.get('chips', []):
                        if chip['tmnBinary'] == TMN_binary:
                            result += (f"Model Name: {chip.get('modelName', 'N/A')}\n\n"
                                       f"TMN (Hex): {chip['tmnHex']}\n"
                                       f"TMN (Binary): {chip['tmnBinary']}\n\n"
                                       f"Product URL: {chip.get('productUrl', 'N/A')}\n\n"
                                       f"Notes: {chip.get('note', 'N/A')}")
                            return result, resultXTID
                    
                    return result + "No matching TMN found.", resultXTID + "No matching XTID found."
            
            return result + "No matching MDID found.", resultXTID + "No matching MDID found."
        except KeyError as e:
            return f"Error: Missing key in data - {e}", ""

def main():
    app = QApplication(sys.argv)
    data = load_json_data()

    if data:
        window = SearchWindow(data)
        window.show()
        sys.exit(app.exec_())
    else:
        print("Error loading data. Exiting...")
        sys.exit(1)

if __name__ == '__main__':
    main()
